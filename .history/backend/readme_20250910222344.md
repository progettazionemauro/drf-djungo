#  Introduzione
## ðŸ“– Prefazione â€“ Manifesto dellâ€™Open Source e del Progetto _DjungÅ_

Viviamo in unâ€™epoca paradossale: siamo circondati da informazioni, ma allo stesso tempo prigionieri di una frammentazione che rende difficile raccoglierle, organizzarle, renderle vive nel momento in cui ne abbiamo bisogno. Prima ancora che lâ€™intelligenza artificiale esplodesse, il marketing e la logica della segmentazione avevano giÃ  spezzettato la conoscenza in mille rivoli, rendendo arduo il compito di collegare e ricostruire un quadro unitario.

Oggi lâ€™IA si trova nel punto piÃ¹ alto mai raggiunto dal sapere umano. Ãˆ vero: i progressi sono vertiginosi e ciÃ² che oggi ci sembra avanzatissimo sarÃ  presto obsoleto. Ma non illudiamoci: il futuro dellâ€™IA non sarÃ  accessibile a tutti. Pagamenti, restrizioni statali, interessi di mercato: tutto rema nella direzione di chiudere e recintare lâ€™accesso a questa conoscenza.

Non Ã¨ la prima volta che accade. Negli anni â€™80, Richard Stallman e la Free Software Foundation lanciarono un grido simile: la libertÃ  del software non era un lusso per pochi hacker, ma una questione di civiltÃ . Quella battaglia diede vita al movimento del software libero e successivamente allâ€™open source, gettando le basi per gran parte delle tecnologie che oggi usiamo senza quasi rendercene conto.

Il progetto _DjungÅ_ si colloca su questa stessa linea storica: vuole essere un atto di liberazione.  
Un sistema che unisce backend e frontend, pensato per non essere controllato da pochi, ma per restare nelle mani di chi lo usa.  
Un sistema che puÃ² girare su un semplice PC locale, senza dipendere da grandi infrastrutture.  
Un sistema che permette di immagazzinare i nostri articoli, ricordi e fonti sia online che in locale, restituendo allâ€™individuo il controllo sulla propria informazione.

Questo libro non Ã¨ quindi soltanto un manuale tecnico. Ãˆ un invito. Ãˆ un manifesto. Ãˆ la dichiarazione di un principio fondamentale: la conoscenza deve tornare ad essere **nostra**, gestibile, aggregabile, indipendente.

----------

## ðŸ“œ Manifesto dellâ€™Open Source â€“ versione sintetica

1.  **La conoscenza deve essere libera.**  
    Non piÃ¹ frammentata da marketing e segmentazioni di mercato.
    
2.  **Lâ€™IA Ã¨ al suo apice, ma non sarÃ  per tutti.**  
    I muri di pagamento e le barriere istituzionali renderanno lâ€™accesso sempre piÃ¹ elitario.
    
3.  **Il software deve restare nostro.**  
    Backend e frontend devono girare ovunque: sul server come sul PC di casa.
    Anche i tool collegati debbono essere open source.
    
4.  **Il progetto _DjungÅ_ nasce per ridare potere allâ€™individuo.**  
    Informazioni, articoli, ricordi: tutto deve essere archiviabile e aggregabile senza dipendere da terzi.
    
5.  **Open Source come atto di liberazione.**  
    Non un vezzo tecnico, ma una scelta politica, culturale ed
## Tools 
Ogni manifesto che si rispetti non resta solo teoria: ha bisogno di strumenti concreti, quotidiani, che permettano di trasformare le idee in pratica. Nel mio caso, il punto di partenza Ã¨ stato banale e rivoluzionario allo stesso tempo: **scrivere bene in Markdown**.

### PerchÃ© Markdown?

Markdown Ã¨ il linguaggio di scrittura piÃ¹ semplice e potente per documentare progetti, creare appunti strutturati, redigere articoli e â€” soprattutto â€” per scrivere il celebre `README.md`, il biglietto da visita di ogni progetto su GitHub. Ãˆ leggibile da chiunque come testo puro e al tempo stesso si converte in una formattazione elegante e standardizzata.

In un mondo dominato da formati proprietari (Word, Pages, ecc.), Markdown Ã¨ la scelta naturale per chi vuole libertÃ , leggerezza e portabilitÃ .

### PerchÃ© StackEdit?

Ci sono molti editor di Markdown, ma il primo strumento che ho scelto Ã¨ **StackEdit**:

-   Funziona direttamente dal browser, senza installazioni pesanti.
    
-   Salva in locale (cache o localStorage), senza dipendere da un â€œserver centraleâ€.
    
-   Si integra facilmente con **GitHub**, **Google Drive** e **Dropbox**, permettendo di sincronizzare i file Markdown.
    
-   Ha unâ€™anteprima in tempo reale che ti fa vedere come il tuo testo diventerÃ  una volta pubblicato.
    

StackEdit Ã¨, per me, il ponte ideale: da una parte la scrittura libera e immediata, dallâ€™altra la possibilitÃ  di collegare tutto a GitHub, il luogo naturale dove ogni progetto open source trova casa.

### Il legame con Visual Studio Code

Naturalmente, StackEdit non Ã¨ lâ€™unico editor della mia cassetta degli attrezzi. Una volta scritto e rifinito un documento, passo in **Visual Studio Code** (VS Code). Qui entrano in gioco estensioni dedicate come:

-   **Markdown All in One** (per formattare e gestire meglio i file `.md`),
    
-   **Paste Markdown** (per incollare direttamente testo giÃ  convertito),
    
-   **Markdown Preview Enhanced** (per avere unâ€™anteprima curata).
    

VS Code diventa il laboratorio dove Markdown e codice convivono: lo stesso editor dove scrivo funzioni Python o configurazioni di Django Ã¨ anche il luogo in cui rifinisco i miei `README.md`.

### E infine: GitHub

Il ciclo si chiude (o meglio, si apre al mondo) con GitHub. LÃ¬ il `README.md` non Ã¨ un file qualunque: Ã¨ la prima cosa che chiunque vede entrando nel repository. Un biglietto da visita, un manifesto del progetto, un segnale di serietÃ .  
Grazie a StackEdit e VS Code, il `README.md` prende forma senza attriti e diventa pubblicabile su GitHub con un semplice commit.
##  Scrittura
- [Stackedit](https://stackedit.io/app#) 

# ðŸš€ Deploy DjungÅ (blue-green) â€” Backend DRF + Frontend Hugo

Questa guida descrive come mettere online unâ€™istanza di **Django REST Framework** (backend) e **Hugo** (frontend statico) su un server Hetzner, adottando la strategia **blue-green deployment**.

Lâ€™idea: mantenere due ambienti (`blue` e `green`) cosÃ¬ che uno sia attivo e lâ€™altro pronto per il prossimo deploy senza downtime.

----------


____

## 0) Obiettivi e naming (blue-green)

-   **Backend (DRF)**: gira su porta interna `9001`, dietro Nginx.
    
    > La porta non Ã¨ esposta direttamente a Internet: solo Nginx ci parla.
    
-   **Frontend (Hugo)**: statici serviti in `/var/www/djungo2` sotto il path `/djungo2/`.
    
    > Manteniamo i file statici fuori dal codice del backend.
    
-   **API nuove**: raggiungibili via `/api2/` â†’ proxy a `127.0.0.1:9001`.
    
    > Usare un path separato evita conflitti con API esistenti.
    
-   **Ambienti**: niente variabili condivise tra locale e server.
    
    > Ogni ambiente ha il suo `.env` dedicato (server â‰  locale).
    

----------
0bis) Flusso GitHub â†’ Hetzner â†’ Locale

Il progetto DjungÅ vive in tre ambienti distinti:

GitHub (master): repository centrale, sorgente di veritÃ . Tutto il codice e le Actions partono da qui.

Hetzner (cloud): ambiente di produzione, riceve i deploy via GitHub Actions o manualmente.

Locale (VSC): ambiente di sviluppo, usato per test e debug.

Variabili di ambiente

Uno dei punti critici Ã¨ che le variabili cambiano da ambiente ad ambiente.
Per questo si adottano file separati:

.env.dev â†’ locale (DEBUG attivo, DB SQLite o Postgres locale).

GitHub Secrets â†’ Action (DATABASE_URL, SECRET_KEY, ecc.).

.env â†’ sul server Hetzner (produzione, DEBUG=False, DB cloud).

ðŸ”‘ Regola dâ€™oro: mai committare .env.
Solo GitHub Actions e Hetzner devono leggere i valori reali.

Flusso tipico

Sviluppi in locale (.env.dev).

Fai push su GitHub (repo master).

GitHub Action esegue: build, test, rsync/ssh su Hetzner, migrate, collectstatic.

Hetzner carica il suo .env e avvia Gunicorn/Nginx.

In questo modo:

GitHub Ã¨ il master,

Hetzner Ã¨ il cloud,

locale Ã¨ il laboratorio.

----------

## 1) Preparazione server (una volta sola)

`apt update && apt -y install git curl build-essential ufw python3-pip python3-venv nginx

ufw allow OpenSSH
ufw allow 80
ufw allow 443
ufw --force enable` 

> Installa tool di base, Python, Nginx e abilita firewall con accesso solo a **SSH, HTTP e HTTPS**.

----------

## 2) Struttura cartelle (nuovo â€œgreenâ€)

`mkdir -p /opt/djungo2/app mkdir -p /opt/djungo2/run mkdir -p /opt/djungo2/log chown -R root:root /opt/djungo2` 

> `/opt/djungo2` diventa la root del nuovo stack â€œgreenâ€:
> 
> -   `app`: codice e virtualenv
>     
> -   `run`: pidfile e socket
>     
> -   `log`: log centralizzati
>     

----------

## 3) Trasferimento progetto (scegli uno)

### A) Clonare da Git (consigliato)

`cd /opt/djungo2/app
git clone GIT_REPO_URL .
git checkout BRANCH_VERDE # es. main, staging, release/x.y` 

> Approccio pulito, versionato e ripetibile.

----------

### B) Da locale con `rsync`

`rsync -avz --delete --exclude '.venv' --exclude '.git' \
./PERCORSO_PROGETTO/ root@65.21.176.227:/opt/djungo2/app/` 

> PiÃ¹ rapido se non vuoi usare Git, ma meno tracciabile.  
> **Nota**: escludiamo `.venv` e `.git`.

----------

## 4) Virtualenv + dipendenze

`cd /opt/djungo2/app
python3 -m venv .venv source .venv/bin/activate
pip install --upgrade pip wheel
pip install -r requirements.txt` 

> Ambiente isolato per le dipendenze Python.

----------

## 5) Variabili dâ€™ambiente (separate!)

Crea solo sul server:

`nano /opt/djungo2/app/.env` 

Esempio:

`DJANGO_SETTINGS_MODULE=yourproject.settings.production SECRET_KEY=***metti-chiave-server*** DEBUG=False  ALLOWED_HOSTS=65.21.176.227,example.com DATABASE_URL=postgres://USER:PASS@HOST:5432/DBNAME` 

Permessi:

`chmod 600 /opt/djungo2/app/.env` 

> Mai committare `.env`!  
> Deve esistere solo sul server.

----------

## 6) Migrazioni + statici (prima accensione)

`cd /opt/djungo2/app source .venv/bin/activate
python manage.py migrate --noinput
python manage.py collectstatic --noinput` 

> Esegui database migrations e raccogli i file statici.

----------

## 7) Gunicorn come service systemd

Crea `/etc/systemd/system/djungo2.service`:

`[Unit]  Description=DjungÅ DRF (green) via Gunicorn After=network.target [Service]  User=root WorkingDirectory=/opt/djungo2/app EnvironmentFile=/opt/djungo2/app/.env ExecStart=/opt/djungo2/app/.venv/bin/gunicorn yourproject.wsgi:application \
  --bind 127.0.0.1:9001 \
  --workers 3 \
  --timeout 60 \
  --access-logfile /opt/djungo2/log/gunicorn_access.log \
  --error-logfile /opt/djungo2/log/gunicorn_error.log \
  --pid /opt/djungo2/run/gunicorn.pid Restart=always [Install]  WantedBy=multi-user.target` 

Avvio:

`systemctl daemon-reload
systemctl enable djungo2
systemctl start djungo2
systemctl status djungo2 --no-pager` 

> Usa `curl -I http://127.0.0.1:9001/` per testare la risposta del backend.

----------

## 8) Hugo build e pubblicazione

Build locale:

`hugo --minify
rsync -avz ./public/ root@65.21.176.227:/var/www/djungo2/` 

Permessi:

`mkdir -p /var/www/djungo2 chown -R www-data:www-data /var/www/djungo2` 

> Hugo genera file statici â†’ trasferiti in `/var/www/djungo2`.

----------

## 9) Nginx (reverse proxy + statici)

Crea `/etc/nginx/sites-available/djungo2.conf`:

`server { listen  80; server_name  65.21.176.227; # Hugo static under /djungo2/  location /djungo2/ { alias /var/www/djungo2/; index index.html; try_files  $uri  $uri/ /index.html;
    } # Django API under /api2/  location /api2/ { proxy_pass http://127.0.0.1:9001/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; client_max_body_size  20m;
    } # sicurezza base  add_header X-Frame-Options SAMEORIGIN; add_header X-Content-Type-Options nosniff; add_header Referrer-Policy strict-origin-when-cross-origin; add_header X-XSS-Protection "1; mode=block";
}` 

Attiva:

`ln -s /etc/nginx/sites-available/djungo2.conf /etc/nginx/sites-enabled/
nginx -t && systemctl reload nginx` 

Test esterno:

-   `http://65.21.176.227/djungo2/` â†’ Hugo
    
-   `http://65.21.176.227/api2/` â†’ DRF
    

----------

## 10) Healthcheck

Aggiungi in DRF un endpoint `/health/` che risponde:

`{"ok":  true}` 

> Serve a monitorare lo stato del servizio.

----------

## 11) Logrotate

Crea `/etc/logrotate.d/djungo2`:

`/opt/djungo2/log/*.log {
    daily
    rotate 14
    compress
    missingok
    notifempty
    copytruncate
}` 

> Mantieni log sotto controllo.

----------

## 12) Hardening (post-verifica)

-   SSH:
    
    `sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
    systemctl restart ssh` 
    
-   HTTPS con Certbot:
    
    `apt -y install certbot python3-certbot-nginx
    certbot --nginx -d TUO_DOMINIO` 
    

----------

## 13) GitHub Actions (step successivo)

Workflow tipico:

-   build + test
    
-   rsync/ssh â†’ `/opt/djungo2/app`
    
-   `pip install -r requirements.txt`
    
-   `migrate`, `collectstatic`
    
-   restart Gunicorn
    
-   healthcheck su `/api2/health/`
    

Segreti â†’ GitHub Secrets (SSH key di deploy dedicata).

----------

## âœ… CriticitÃ  giÃ  viste (e fixate)

-   **Chiavi SSH**: usa `~/.ssh/config` con `IdentitiesOnly yes`.
    
-   **sshd_config**: occhio agli override in `sshd_config.d/`.
    
-   **Permessi**: `.env` (600), `.ssh` (700), `authorized_keys` (600).
    
-   **Nginx**: attenzione al trailing slash in `proxy_pass`.
    
-   **Blue-green**: mantieni vecchio stack finchÃ© il nuovo non Ã¨ validato.
    