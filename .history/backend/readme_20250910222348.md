#  Introduzione
## üìñ Prefazione ‚Äì Manifesto dell‚ÄôOpen Source e del Progetto _Djung≈ç_

Viviamo in un‚Äôepoca paradossale: siamo circondati da informazioni, ma allo stesso tempo prigionieri di una frammentazione che rende difficile raccoglierle, organizzarle, renderle vive nel momento in cui ne abbiamo bisogno. Prima ancora che l‚Äôintelligenza artificiale esplodesse, il marketing e la logica della segmentazione avevano gi√† spezzettato la conoscenza in mille rivoli, rendendo arduo il compito di collegare e ricostruire un quadro unitario.

Oggi l‚ÄôIA si trova nel punto pi√π alto mai raggiunto dal sapere umano. √à vero: i progressi sono vertiginosi e ci√≤ che oggi ci sembra avanzatissimo sar√† presto obsoleto. Ma non illudiamoci: il futuro dell‚ÄôIA non sar√† accessibile a tutti. Pagamenti, restrizioni statali, interessi di mercato: tutto rema nella direzione di chiudere e recintare l‚Äôaccesso a questa conoscenza.

Non √® la prima volta che accade. Negli anni ‚Äô80, Richard Stallman e la Free Software Foundation lanciarono un grido simile: la libert√† del software non era un lusso per pochi hacker, ma una questione di civilt√†. Quella battaglia diede vita al movimento del software libero e successivamente all‚Äôopen source, gettando le basi per gran parte delle tecnologie che oggi usiamo senza quasi rendercene conto.

Il progetto _Djung≈ç_ si colloca su questa stessa linea storica: vuole essere un atto di liberazione.  
Un sistema che unisce backend e frontend, pensato per non essere controllato da pochi, ma per restare nelle mani di chi lo usa.  
Un sistema che pu√≤ girare su un semplice PC locale, senza dipendere da grandi infrastrutture.  
Un sistema che permette di immagazzinare i nostri articoli, ricordi e fonti sia online che in locale, restituendo all‚Äôindividuo il controllo sulla propria informazione.

Questo libro non √® quindi soltanto un manuale tecnico. √à un invito. √à un manifesto. √à la dichiarazione di un principio fondamentale: la conoscenza deve tornare ad essere **nostra**, gestibile, aggregabile, indipendente.

----------

## üìú Manifesto dell‚ÄôOpen Source ‚Äì versione sintetica

1.  **La conoscenza deve essere libera.**  
    Non pi√π frammentata da marketing e segmentazioni di mercato.
    
2.  **L‚ÄôIA √® al suo apice, ma non sar√† per tutti.**  
    I muri di pagamento e le barriere istituzionali renderanno l‚Äôaccesso sempre pi√π elitario.
    
3.  **Il software deve restare nostro.**  
    Backend e frontend devono girare ovunque: sul server come sul PC di casa.
    Anche i tool collegati debbono essere open source.
    
4.  **Il progetto _Djung≈ç_ nasce per ridare potere all‚Äôindividuo.**  
    Informazioni, articoli, ricordi: tutto deve essere archiviabile e aggregabile senza dipendere da terzi.
    
5.  **Open Source come atto di liberazione.**  
    Non un vezzo tecnico, ma una scelta politica, culturale ed
## Tools 
Ogni manifesto che si rispetti non resta solo teoria: ha bisogno di strumenti concreti, quotidiani, che permettano di trasformare le idee in pratica. Nel mio caso, il punto di partenza √® stato banale e rivoluzionario allo stesso tempo: **scrivere bene in Markdown**.

### Perch√© Markdown?

Markdown √® il linguaggio di scrittura pi√π semplice e potente per documentare progetti, creare appunti strutturati, redigere articoli e ‚Äî soprattutto ‚Äî per scrivere il celebre `README.md`, il biglietto da visita di ogni progetto su GitHub. √à leggibile da chiunque come testo puro e al tempo stesso si converte in una formattazione elegante e standardizzata.

In un mondo dominato da formati proprietari (Word, Pages, ecc.), Markdown √® la scelta naturale per chi vuole libert√†, leggerezza e portabilit√†.

### Perch√© StackEdit?

Ci sono molti editor di Markdown, ma il primo strumento che ho scelto √® **StackEdit**:

-   Funziona direttamente dal browser, senza installazioni pesanti.
    
-   Salva in locale (cache o localStorage), senza dipendere da un ‚Äúserver centrale‚Äù.
    
-   Si integra facilmente con **GitHub**, **Google Drive** e **Dropbox**, permettendo di sincronizzare i file Markdown.
    
-   Ha un‚Äôanteprima in tempo reale che ti fa vedere come il tuo testo diventer√† una volta pubblicato.
    

StackEdit √®, per me, il ponte ideale: da una parte la scrittura libera e immediata, dall‚Äôaltra la possibilit√† di collegare tutto a GitHub, il luogo naturale dove ogni progetto open source trova casa.

### Il legame con Visual Studio Code

Naturalmente, StackEdit non √® l‚Äôunico editor della mia cassetta degli attrezzi. Una volta scritto e rifinito un documento, passo in **Visual Studio Code** (VS Code). Qui entrano in gioco estensioni dedicate come:

-   **Markdown All in One** (per formattare e gestire meglio i file `.md`),
    
-   **Paste Markdown** (per incollare direttamente testo gi√† convertito),
    
-   **Markdown Preview Enhanced** (per avere un‚Äôanteprima curata).
    

VS Code diventa il laboratorio dove Markdown e codice convivono: lo stesso editor dove scrivo funzioni Python o configurazioni di Django √® anche il luogo in cui rifinisco i miei `README.md`.

### E infine: GitHub

Il ciclo si chiude (o meglio, si apre al mondo) con GitHub. L√¨ il `README.md` non √® un file qualunque: √® la prima cosa che chiunque vede entrando nel repository. Un biglietto da visita, un manifesto del progetto, un segnale di seriet√†.  
Grazie a StackEdit e VS Code, il `README.md` prende forma senza attriti e diventa pubblicabile su GitHub con un semplice commit.
##  Scrittura
- [Stackedit](https://stackedit.io/app#) 

# üöÄ Deploy Djung≈ç (blue-green) ‚Äî Backend DRF + Frontend Hugo

Questa guida descrive come mettere online un‚Äôistanza di **Django REST Framework** (backend) e **Hugo** (frontend statico) su un server Hetzner, adottando la strategia **blue-green deployment**.

L‚Äôidea: mantenere due ambienti (`blue` e `green`) cos√¨ che uno sia attivo e l‚Äôaltro pronto per il prossimo deploy senza downtime.

----------
## ‚öôÔ∏è Setup Tecnico ‚Äì Ambienti e Deploy

Il progetto _Djung≈ç_ non vive solo di teoria: per funzionare davvero ha bisogno di una struttura tecnica solida.  
In questa sezione documentiamo come mantenere in sincronia i tre ambienti fondamentali:

- **Locale (sviluppo in VS Code)**  
- **GitHub (backup e versionamento del codice)**  
- **Hetzner (produzione con Django + Hugo)**  

Il problema centrale √® che le **variabili di ambiente** cambiano a seconda del contesto.  
La soluzione: un sistema di **.env multipli**, un **settings.py intelligente** e uno **script di deploy** che tiene tutto in linea.

---

### üìÇ Struttura dei file chiave

drf_hugo_vue/
‚îú‚îÄ‚îÄ backend/
‚îÇ ‚îú‚îÄ‚îÄ backend/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ settings.py # configurato per .env multipli
‚îÇ ‚îú‚îÄ‚îÄ .env.dev # ambiente locale (non su GitHub)
‚îÇ ‚îú‚îÄ‚îÄ .env.prod # ambiente Hetzner (solo su server)
‚îÇ ‚îú‚îÄ‚îÄ .env.example # modello committato su GitHub
‚îÇ ‚îú‚îÄ‚îÄ manage.py
‚îÇ ‚îî‚îÄ‚îÄ static/ # cartella statica (locale)
‚îú‚îÄ‚îÄ deploy_and_sync.sh # script di deploy sicuro
‚îî‚îÄ‚îÄ .gitignore # aggiornato con esclusioni critiche

yaml
Copia codice

---

### üìù `.gitignore`

Evitare che segreti e DB finiscano su GitHub √® la prima regola.  
Ecco il file aggiornato:

```gitignore
# Env
.env
.env.*
!.env.example

# Virtualenv & cache
env/
venv/
__pycache__/
*.pyc

# DB locali
db.sqlite3
*.sqlite3
backups/

# Statici e build Hugo
.static/
staticfiles/
public/
sgb_start/public/

# Log
*.log
.settings_debug.log
.manage_posts.log
.DS_Store
*.cache
Crea anche .env.example (questo va su GitHub):

env
Copia codice
SECRET_KEY=CHANGE_ME
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1
CSRF_TRUSTED_ORIGINS=http://localhost:8000
DATABASE_URL=sqlite:///db.sqlite3
DJANGO_STATIC_PATH=static
DJANGO_STATIC_ROOT=staticfiles
CORS_ALLOWED_ORIGINS=http://localhost:1313
HUGO_ENV=development
HUGO_BASEURL=http://localhost:1313
‚öôÔ∏è Dipendenze necessarie
Installa queste librerie nel tuo venv:

bash
Copia codice
pip install python-dotenv dj-database-url django-cors-headers
üß© settings.py intelligente
Il file backend/settings.py √® stato riscritto per:

caricare automaticamente .env, .env.prod o .env.dev;

permettere override via ENV_FILE;

gestire il DB via dj-database-url;

integrare corsheaders;

scrivere un file settings_debug.log con i valori effettivi.

python
Copia codice
import os
import logging
from pathlib import Path
from dotenv import load_dotenv
import dj_database_url

BASE_DIR = Path(__file__).resolve().parent.parent

# === Caricamento .env (ordine: .env -> .env.prod -> .env.dev) ===
env_candidates = [
    BASE_DIR / ".env",
    BASE_DIR / ".env.prod",
    BASE_DIR / ".env.dev",
]
override = os.getenv("ENV_FILE")
if override and (BASE_DIR / override).exists():
    env_path = BASE_DIR / override
else:
    env_path = next((p for p in env_candidates if p.exists()), None)

if env_path:
    if os.getenv("PRINT_ENV_LOAD", "1") == "1":
        print(f"üîÑ Loading env file: {env_path}")
    load_dotenv(dotenv_path=env_path)
else:
    print("‚ö†Ô∏è Nessun file .env trovato tra .env, .env.prod, .env.dev")

# === Config base ===
SECRET_KEY = os.getenv("SECRET_KEY", "django-insecure-change-me")
DEBUG = os.getenv("DEBUG", "False").strip().lower() in ("true", "1", "yes")
ALLOWED_HOSTS = [h.strip() for h in os.getenv("ALLOWED_HOSTS", "127.0.0.1,localhost").split(",") if h.strip()]
CSRF_TRUSTED_ORIGINS = [o.strip() for o in os.getenv("CSRF_TRUSTED_ORIGINS", "").split(",") if o.strip()]

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "movies",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

if os.getenv("CORS_ALLOW_ALL", "0") in ("1", "true", "True"):
    CORS_ALLOW_ALL_ORIGINS = True
else:
    CORS_ALLOWED_ORIGINS = [o.strip() for o in os.getenv(
        "CORS_ALLOWED_ORIGINS",
        "http://localhost:1313,http://127.0.0.1:1313,http://127.0.0.1:8000"
    ).split(",") if o.strip()]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "debug": DEBUG,
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.wsgi.application"

DATABASES = {
    "default": dj_database_url.parse(
        os.getenv("DATABASE_URL", "sqlite:///db.sqlite3"),
        conn_max_age=600,
        ssl_require=False if DEBUG else False,
    )
}
if DATABASES["default"]["ENGINE"] == "django.db.backends.sqlite3":
    name = DATABASES["default"]["NAME"]
    if not os.path.isabs(str(name)):
        DATABASES["default"]["NAME"] = str(BASE_DIR / name)

STATIC_URL = "/static/"
STATIC_ROOT = os.getenv("DJANGO_STATIC_ROOT", str(BASE_DIR / "staticfiles"))
STATICFILES_DIRS = [ BASE_DIR / os.getenv("DJANGO_STATIC_PATH", "static") ]

REST_FRAMEWORK = { "DEFAULT_AUTHENTICATION_CLASSES": [] }

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Debug dump
try:
    with open(BASE_DIR / "settings_debug.log", "w") as f:
        f.write(f"DEBUG: {DEBUG}\n")
        f.write(f"ALLOWED_HOSTS: {ALLOWED_HOSTS}\n")
        f.write(f"STATICFILES_DIRS: {STATICFILES_DIRS}\n")
        f.write(f"STATIC_ROOT: {STATIC_ROOT}\n")
        f.write(f"DATABASE: {DATABASES}\n")
except Exception as e:
    print("‚ö†Ô∏è Impossibile scrivere settings_debug.log:", e)
üåç Profili .env
üîß .env.dev (locale)
env
Copia codice
SECRET_KEY=django-dev-only-change-me
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1
CSRF_TRUSTED_ORIGINS=http://localhost:8000,http://127.0.0.1:8000
DATABASE_URL=sqlite:///db.sqlite3

DJANGO_STATIC_PATH=static
DJANGO_STATIC_ROOT=staticfiles

CORS_ALLOWED_ORIGINS=http://localhost:1313,http://127.0.0.1:1313,http://127.0.0.1:8000
HUGO_ENV=development
HUGO_BASEURL=http://localhost:1313
üåê .env.prod (Hetzner)
env
Copia codice
SECRET_KEY=***PUT_A_STRONG_SECRET***
DEBUG=False
ALLOWED_HOSTS=sgbh.org,*.sgbh.org,127.0.0.1,localhost
CSRF_TRUSTED_ORIGINS=https://sgbh.org,https://www.sgbh.org
DATABASE_URL=sqlite:////opt/djungo/db.sqlite3

DJANGO_STATIC_PATH=static
DJANGO_STATIC_ROOT=/opt/djungo/staticfiles

CORS_ALLOWED_ORIGINS=https://sgbh.org,https://www.sgbh.org
HUGO_ENV=production
HUGO_BASEURL=https://sgbh.org
üìã .env.example (committato)
env
Copia codice
SECRET_KEY=CHANGE_ME
DEBUG=True
ALLOWED_HOSTS=localhost,127.0.0.1
CSRF_TRUSTED_ORIGINS=http://localhost:8000
DATABASE_URL=sqlite:///db.sqlite3
DJANGO_STATIC_PATH=static
DJANGO_STATIC_ROOT=staticfiles
CORS_ALLOWED_ORIGINS=http://localhost:1313
HUGO_ENV=development
HUGO_BASEURL=http://localhost:1313
üõ†Ô∏è Correzione STATICFILES_DIRS
Per evitare warning in locale:

bash
Copia codice
mkdir -p ~/Scrivania/drf_hugo_vue/backend/static
oppure cambiare nel .env.dev:

env
Copia codice
DJANGO_STATIC_PATH=assets/static
‚úÖ Health check
bash
Copia codice
cd ~/Scrivania/drf_hugo_vue/backend
python manage.py check
Risultato atteso:

nessun avviso .env;

nessun warning staticfiles.W004.

üöö Script di Deploy (deploy_and_sync.sh)
Mantiene in sync locale ‚Üí GitHub ‚Üí Hetzner, builda Hugo, fa backup DB.
Da lanciare dal root del repo:

bash
Copia codice
./deploy_and_sync.sh "Deploy: movies API + Hugo rebuild"
bash
Copia codice
#!/bin/bash
set -euo pipefail

REMOTE_HOST="root@157.180.16.0"
REMOTE_DIR="/opt/djungo"
REMOTE_DB="$REMOTE_DIR/db.sqlite3"
LOCAL_DB="./db.sqlite3"
PASSWORD_FILE="./hetzner_password.txt"
COMMIT_MSG=${1:-"üöÄ Auto deploy + Hugo build"}

if [ ! -f "$PASSWORD_FILE" ]; then
  echo "‚ùå Password file $PASSWORD_FILE not found. Aborting."
  exit 1
fi
SSH_PASSWORD=$(<"$PASSWORD_FILE")

echo "üì¶ [1/6] Push code to GitHub..."
git add .
git reset "$LOCAL_DB" 2>/dev/null || true
git commit -m "$COMMIT_MSG" || echo "‚ÑπÔ∏è Nothing to commit."
git push origin main

echo "üßπ [2/6] Clean Hugo public/ on Hetzner..."
sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no $REMOTE_HOST "cd $REMOTE_DIR/sgb_start && rm -rf public || true"

echo "üåê [3/6] Pull latest code on Hetzner..."
sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no $REMOTE_HOST \
  "cd $REMOTE_DIR && git fetch origin && git reset --hard origin/main"

echo "üèóÔ∏è [4/6] Build Hugo (prod) on Hetzner..."
sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no $REMOTE_HOST "
  set -e
  export ENV_FILE=.env.prod
  set -a; [ -f \"$REMOTE_DIR/\$ENV_FILE\" ] && . \"$REMOTE_DIR/\$ENV_FILE\"; set +a
  cd $REMOTE_DIR/sgb_start
  hugo --minify --baseURL \"\$HUGO_BASEURL\"
"

# (Opzionale) restart servizi Gunicorn/Nginx
# sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no $REMOTE_HOST "systemctl restart gunicorn && systemctl reload nginx"

echo "üß¨ [5/6] Backup DB to local backups/"
mkdir -p backups/db
STAMP=$(date '+%Y%m%d_%H%M%S')
LOCAL_BACKUP="backups/db/db_${STAMP}.sqlite3"
sshpass -p "$SSH_PASSWORD" scp $REMOTE_HOST:$REMOTE_DB "$LOCAL_BACKUP" || echo "‚ö†Ô∏è DB download skipped/failed."

echo "‚úÖ Done!"
üì° Runbook
Locale (sviluppo):

bash
Copia codice
cd ~/Scrivania/drf_hugo_vue/backend
python manage.py runserver 0.0.0.0:8000
Hugo in locale:

bash
Copia codice
cd ~/Scrivania/drf_hugo_vue/sgb_start
hugo server -D
Deploy in produzione (Hetzner):

bash
Copia codice
./deploy_and_sync.sh "Deploy: new movies API + Hugo rebuild"
üîç Checklist finale
.env.dev presente in backend/ e non committato

.env.prod presente su Hetzner (/opt/djungo/)

.env.example committato su GitHub

settings_debug.log generato correttamente

sgb_start/public/ escluso dal repo

DB backup salvato in backups/db/ (mai su GitHub)

yaml
Copia codice

---

Vuoi che ti prepari anche la parte **successiva al deploy** (nginx + systemd su Hetzner) cos√¨ completiamo il capitolo ‚ÄúSetup Tecnico‚Äù del README, o preferisci fermarci qui?





Chiedi a ChatGPT





ChatGPT pu√≤ commettere errori. Assicurati di verificare le

____

## 0) Obiettivi e naming (blue-green)

-   **Backend (DRF)**: gira su porta interna `9001`, dietro Nginx.
    
    > La porta non √® esposta direttamente a Internet: solo Nginx ci parla.
    
-   **Frontend (Hugo)**: statici serviti in `/var/www/djungo2` sotto il path `/djungo2/`.
    
    > Manteniamo i file statici fuori dal codice del backend.
    
-   **API nuove**: raggiungibili via `/api2/` ‚Üí proxy a `127.0.0.1:9001`.
    
    > Usare un path separato evita conflitti con API esistenti.
    
-   **Ambienti**: niente variabili condivise tra locale e server.
    
    > Ogni ambiente ha il suo `.env` dedicato (server ‚â† locale).
    

----------
0bis) Flusso GitHub ‚Üí Hetzner ‚Üí Locale

Il progetto Djung≈ç vive in tre ambienti distinti:

GitHub (master): repository centrale, sorgente di verit√†. Tutto il codice e le Actions partono da qui.

Hetzner (cloud): ambiente di produzione, riceve i deploy via GitHub Actions o manualmente.

Locale (VSC): ambiente di sviluppo, usato per test e debug.

Variabili di ambiente

Uno dei punti critici √® che le variabili cambiano da ambiente ad ambiente.
Per questo si adottano file separati:

.env.dev ‚Üí locale (DEBUG attivo, DB SQLite o Postgres locale).

GitHub Secrets ‚Üí Action (DATABASE_URL, SECRET_KEY, ecc.).

.env ‚Üí sul server Hetzner (produzione, DEBUG=False, DB cloud).

üîë Regola d‚Äôoro: mai committare .env.
Solo GitHub Actions e Hetzner devono leggere i valori reali.

Flusso tipico

Sviluppi in locale (.env.dev).

Fai push su GitHub (repo master).

GitHub Action esegue: build, test, rsync/ssh su Hetzner, migrate, collectstatic.

Hetzner carica il suo .env e avvia Gunicorn/Nginx.

In questo modo:

GitHub √® il master,

Hetzner √® il cloud,

locale √® il laboratorio.

----------

## 1) Preparazione server (una volta sola)

`apt update && apt -y install git curl build-essential ufw python3-pip python3-venv nginx

ufw allow OpenSSH
ufw allow 80
ufw allow 443
ufw --force enable` 

> Installa tool di base, Python, Nginx e abilita firewall con accesso solo a **SSH, HTTP e HTTPS**.

----------

## 2) Struttura cartelle (nuovo ‚Äúgreen‚Äù)

`mkdir -p /opt/djungo2/app mkdir -p /opt/djungo2/run mkdir -p /opt/djungo2/log chown -R root:root /opt/djungo2` 

> `/opt/djungo2` diventa la root del nuovo stack ‚Äúgreen‚Äù:
> 
> -   `app`: codice e virtualenv
>     
> -   `run`: pidfile e socket
>     
> -   `log`: log centralizzati
>     

----------

## 3) Trasferimento progetto (scegli uno)

### A) Clonare da Git (consigliato)

`cd /opt/djungo2/app
git clone GIT_REPO_URL .
git checkout BRANCH_VERDE # es. main, staging, release/x.y` 

> Approccio pulito, versionato e ripetibile.

----------

### B) Da locale con `rsync`

`rsync -avz --delete --exclude '.venv' --exclude '.git' \
./PERCORSO_PROGETTO/ root@65.21.176.227:/opt/djungo2/app/` 

> Pi√π rapido se non vuoi usare Git, ma meno tracciabile.  
> **Nota**: escludiamo `.venv` e `.git`.

----------

## 4) Virtualenv + dipendenze

`cd /opt/djungo2/app
python3 -m venv .venv source .venv/bin/activate
pip install --upgrade pip wheel
pip install -r requirements.txt` 

> Ambiente isolato per le dipendenze Python.

----------

## 5) Variabili d‚Äôambiente (separate!)

Crea solo sul server:

`nano /opt/djungo2/app/.env` 

Esempio:

`DJANGO_SETTINGS_MODULE=yourproject.settings.production SECRET_KEY=***metti-chiave-server*** DEBUG=False  ALLOWED_HOSTS=65.21.176.227,example.com DATABASE_URL=postgres://USER:PASS@HOST:5432/DBNAME` 

Permessi:

`chmod 600 /opt/djungo2/app/.env` 

> Mai committare `.env`!  
> Deve esistere solo sul server.

----------

## 6) Migrazioni + statici (prima accensione)

`cd /opt/djungo2/app source .venv/bin/activate
python manage.py migrate --noinput
python manage.py collectstatic --noinput` 

> Esegui database migrations e raccogli i file statici.

----------

## 7) Gunicorn come service systemd

Crea `/etc/systemd/system/djungo2.service`:

`[Unit]  Description=Djung≈ç DRF (green) via Gunicorn After=network.target [Service]  User=root WorkingDirectory=/opt/djungo2/app EnvironmentFile=/opt/djungo2/app/.env ExecStart=/opt/djungo2/app/.venv/bin/gunicorn yourproject.wsgi:application \
  --bind 127.0.0.1:9001 \
  --workers 3 \
  --timeout 60 \
  --access-logfile /opt/djungo2/log/gunicorn_access.log \
  --error-logfile /opt/djungo2/log/gunicorn_error.log \
  --pid /opt/djungo2/run/gunicorn.pid Restart=always [Install]  WantedBy=multi-user.target` 

Avvio:

`systemctl daemon-reload
systemctl enable djungo2
systemctl start djungo2
systemctl status djungo2 --no-pager` 

> Usa `curl -I http://127.0.0.1:9001/` per testare la risposta del backend.

----------

## 8) Hugo build e pubblicazione

Build locale:

`hugo --minify
rsync -avz ./public/ root@65.21.176.227:/var/www/djungo2/` 

Permessi:

`mkdir -p /var/www/djungo2 chown -R www-data:www-data /var/www/djungo2` 

> Hugo genera file statici ‚Üí trasferiti in `/var/www/djungo2`.

----------

## 9) Nginx (reverse proxy + statici)

Crea `/etc/nginx/sites-available/djungo2.conf`:

`server { listen  80; server_name  65.21.176.227; # Hugo static under /djungo2/  location /djungo2/ { alias /var/www/djungo2/; index index.html; try_files  $uri  $uri/ /index.html;
    } # Django API under /api2/  location /api2/ { proxy_pass http://127.0.0.1:9001/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; client_max_body_size  20m;
    } # sicurezza base  add_header X-Frame-Options SAMEORIGIN; add_header X-Content-Type-Options nosniff; add_header Referrer-Policy strict-origin-when-cross-origin; add_header X-XSS-Protection "1; mode=block";
}` 

Attiva:

`ln -s /etc/nginx/sites-available/djungo2.conf /etc/nginx/sites-enabled/
nginx -t && systemctl reload nginx` 

Test esterno:

-   `http://65.21.176.227/djungo2/` ‚Üí Hugo
    
-   `http://65.21.176.227/api2/` ‚Üí DRF
    

----------

## 10) Healthcheck

Aggiungi in DRF un endpoint `/health/` che risponde:

`{"ok":  true}` 

> Serve a monitorare lo stato del servizio.

----------

## 11) Logrotate

Crea `/etc/logrotate.d/djungo2`:

`/opt/djungo2/log/*.log {
    daily
    rotate 14
    compress
    missingok
    notifempty
    copytruncate
}` 

> Mantieni log sotto controllo.

----------

## 12) Hardening (post-verifica)

-   SSH:
    
    `sed -i 's/^PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
    systemctl restart ssh` 
    
-   HTTPS con Certbot:
    
    `apt -y install certbot python3-certbot-nginx
    certbot --nginx -d TUO_DOMINIO` 
    

----------

## 13) GitHub Actions (step successivo)

Workflow tipico:

-   build + test
    
-   rsync/ssh ‚Üí `/opt/djungo2/app`
    
-   `pip install -r requirements.txt`
    
-   `migrate`, `collectstatic`
    
-   restart Gunicorn
    
-   healthcheck su `/api2/health/`
    

Segreti ‚Üí GitHub Secrets (SSH key di deploy dedicata).

----------

## ‚úÖ Criticit√† gi√† viste (e fixate)

-   **Chiavi SSH**: usa `~/.ssh/config` con `IdentitiesOnly yes`.
    
-   **sshd_config**: occhio agli override in `sshd_config.d/`.
    
-   **Permessi**: `.env` (600), `.ssh` (700), `authorized_keys` (600).
    
-   **Nginx**: attenzione al trailing slash in `proxy_pass`.
    
-   **Blue-green**: mantieni vecchio stack finch√© il nuovo non √® validato.
    